[/=============================================================================
    Copyright (C) 2013 Cromwell D. Enage

    Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
    [@http://www.boost.org/LICENSE_1_0.txt])
=============================================================================/]

[section:is_mergeable_heap_selector `is_mergeable_heap_selector`]

[section Synopsis]
[reference__is_mergeable_heap_selector]
[endsect]

[section Description]
A __Boost_Heap__ model type is *mergeable* if and only if it defines a member
function `merge()` that takes in a reference-to-non-`const` object of its own
type and returns `void`.  This metafunction evaluates to __mpl_true__ if the
specified selector will cause __container_gen__ to return a mergeable
__Boost_Heap__ model type; it evaluates to __mpl_false__ otherwise.

If __MPL_CFG_NO_HAS_XXX__ is defined, then you must specialize this
metafunction to inherit from __mpl_true__ for your custom selector if and only
if the type to be returned by __container_gen__ is a mergeable __Boost_Heap__
model type.
[endsect]

[section:definition Where defined]
``
#include <__boost_container_gen_is_mergeable_heap_selector_hpp__>
``
[endsect]

[section Example]
The __heap_merge__ function is the only way to merge two objects of different
__Boost_Heap__ model types or of the same __Boost_Heap__ model type that is
otherwise not mergeable.

[example__is_mergeable_heap_selector__false]

However, the __heap_merge__ function may be less efficient than the `merge()`
member function of mergeable __Boost_Heap__ model types.

[example__is_mergeable_heap_selector__true]

Use this metafunction to choose the correct and most efficient merge
implementation.

[example__is_mergeable_heap_selector]
[endsect]

[section Test]
[test__is_mergeable_heap_selector]
[endsect]

[endsect] [/ is_mergeable_heap_selector]

